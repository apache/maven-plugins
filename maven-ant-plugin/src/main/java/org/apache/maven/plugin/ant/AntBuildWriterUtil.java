package org.apache.maven.plugin.ant;

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.IOException;
import java.text.DateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Map;

import javax.xml.parsers.DocumentBuilderFactory;

import org.apache.maven.artifact.Artifact;
import org.apache.maven.model.Plugin;
import org.apache.maven.model.ReportPlugin;
import org.apache.maven.project.MavenProject;
import org.apache.maven.wagon.PathUtils;
import org.apache.xpath.XPathAPI;
import org.apache.xpath.objects.XObject;
import org.codehaus.plexus.util.StringUtils;
import org.codehaus.plexus.util.xml.XMLWriter;
import org.codehaus.plexus.util.xml.Xpp3Dom;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

/**
 * Utility class for the <code>AntBuildWriter</code> class.
 *
 * @author <a href="mailto:vincent.siveton@gmail.com">Vincent Siveton</a>
 * @version $Id$
 */
public class AntBuildWriterUtil
{
    /**
     * @param compileSourceRoots
     * @return not null list
     */
    public static List removeEmptyCompileSourceRoots( List compileSourceRoots )
    {
        List newCompileSourceRootsList = new ArrayList();
        if ( compileSourceRoots != null )
        {
            // copy as I may be modifying it
            for ( Iterator i = compileSourceRoots.iterator(); i.hasNext(); )
            {
                String srcDir = (String) i.next();
                if ( new File( srcDir ).exists() )
                {
                    newCompileSourceRootsList.add( srcDir );
                }
            }
        }

        return newCompileSourceRootsList;
    }

    /**
     * Convenience method to write <code>&lt;include/&gt;</code> and <code>&lt;exclude/&gt;</code>
     *
     * @param writer not null
     * @param includes
     * @param excludes
     */
    public static void writeIncludesExcludes( XMLWriter writer, List includes, List excludes )
    {
        if ( includes != null )
        {
            for ( Iterator i = includes.iterator(); i.hasNext(); )
            {
                String include = (String) i.next();
                writer.startElement( "include" );
                writer.addAttribute( "name", include );
                writer.endElement(); // include
            }
        }
        if ( excludes != null )
        {
            for ( Iterator i = excludes.iterator(); i.hasNext(); )
            {
                String exclude = (String) i.next();
                writer.startElement( "exclude" );
                writer.addAttribute( "name", exclude );
                writer.endElement(); // exclude
            }
        }
    }

    /**
     * Write comments in the Ant build file header
     *
     * @param writer
     */
    public static void writeHeader( XMLWriter writer )
    {
        writeAntVersionHeader( writer );

        writeCommentLineBreak( writer );
        writeComment( writer, StringUtils.repeat( "=", 21 ) + " - DO NOT EDIT THIS FILE! - "
            + StringUtils.repeat( "=", 21 ) );
        writeCommentLineBreak( writer );
        writeComment( writer, " " );
        writeComment( writer, "Any modifications will be overwritten." );
        writeComment( writer, " " );
        DateFormat dateFormat = DateFormat.getDateTimeInstance( DateFormat.SHORT, DateFormat.SHORT, Locale.US );
        writeComment( writer, "Generated by Maven Ant Plugin on "
            + dateFormat.format( new Date( System.currentTimeMillis() ) ) );
        writeComment( writer, "See: http://maven.apache.org/plugins/maven-ant-plugin/" );
        writeComment( writer, " " );
        writeCommentLineBreak( writer );

        writeLineBreak( writer );
    }

    /**
     * Write comment for the Ant supported version
     *
     * @param writer
     */
    public static void writeAntVersionHeader( XMLWriter writer )
    {
        writeCommentText( writer, "Ant build file (http://ant.apache.org/) for Ant 1.6.2 or above.", 0 );
    }

    /**
     * Convenience method to write one <code>CRLF</code>
     *
     * @param writer not null writer
     */
    public static void writeLineBreak( XMLWriter writer )
    {
        writeLineBreak( writer, 1 );
    }

    /**
     * Convenience method to repeat <code>CRLF</code>
     *
     * @param writer not null
     * @param repeat
     */
    public static void writeLineBreak( XMLWriter writer, int repeat )
    {
        for ( int i = 0; i < repeat; i++ )
        {
            writer.writeMarkup( "\n" );
        }
    }

    /**
     * Convenience method to repeat <code>CRLF</code> and to indent the writer
     *
     * @param writer not null
     * @param repeat
     * @param indent postive number
     */
    public static void writeLineBreak( XMLWriter writer, int repeat, int indent )
    {
        writeLineBreak( writer, repeat );

        if ( indent < 0 )
        {
            indent = 0;
        }

        writer.writeText( StringUtils.repeat( " ", indent * AntBuildWriter.DEFAULT_INDENTATION_SIZE ) );
    }

    /**
     * Convenience method to write XML comment line break. Its size is 80.
     *
     * @param writer not null
     */
    public static void writeCommentLineBreak( XMLWriter writer )
    {
        writer.writeMarkup( "<!-- " + StringUtils.repeat( "=", 70 ) + " -->\n" );
    }

    /**
     * Convenience method to write XML comment line. The <code>comment</code> is splitted to have a size of 80.
     *
     * @param writer not null
     * @param comment
     */
    public static void writeComment( XMLWriter writer, String comment )
    {
        if ( comment == null )
        {
            comment = "null";
        }

        String[] words = StringUtils.split( comment, " " );

        StringBuffer line = new StringBuffer( "<!-- " );
        for ( int i = 0; i < words.length; i++ )
        {
            String[] sentences = StringUtils.split( words[i], "\n" );
            if ( sentences.length > 1 )
            {
                for ( int j = 0; j < sentences.length - 1; j++ )
                {
                    line.append( sentences[j] ).append( ' ' );
                    line.append( StringUtils.repeat( " ", 76 - line.length() ) ).append( "-->" ).append( '\n' );
                    writer.writeMarkup( line.toString() );
                    line = new StringBuffer( "<!-- " );
                }
                line.append( sentences[sentences.length - 1] ).append( ' ' );
            }
            else
            {
                StringBuffer sentenceTmp = new StringBuffer( line.toString() );
                sentenceTmp.append( words[i] ).append( ' ' );
                if ( sentenceTmp.length() > 76 )
                {
                    line.append( StringUtils.repeat( " ", 76 - line.length() ) ).append( "-->" ).append( '\n' );
                    writer.writeMarkup( line.toString() );
                    line = new StringBuffer( "<!-- " );
                    line.append( words[i] ).append( ' ' );
                }
                else
                {
                    line.append( words[i] ).append( ' ' );
                }
            }
        }
        if ( line.length() <= 76 )
        {
            line.append( StringUtils.repeat( " ", 76 - line.length() ) ).append( "-->" ).append( '\n' );
        }
        writer.writeMarkup( line.toString() );
    }

    /**
     * Convenience method to write XML comment between two comment line break.
     * The XML comment block is also indented.
     *
     * @param writer not null
     * @param comment
     * @param indent
     */
    public static void writeCommentText( XMLWriter writer, String comment, int indent )
    {
        if ( indent < 0 )
        {
            indent = 0;
        }

        writeLineBreak( writer, 1 );

        writer.writeMarkup( StringUtils.repeat( " ", indent * AntBuildWriter.DEFAULT_INDENTATION_SIZE ) );
        writeCommentLineBreak( writer );

        writer.writeMarkup( StringUtils.repeat( " ", indent * AntBuildWriter.DEFAULT_INDENTATION_SIZE ) );
        writeComment( writer, comment );

        writer.writeMarkup( StringUtils.repeat( " ", indent * AntBuildWriter.DEFAULT_INDENTATION_SIZE ) );
        writeCommentLineBreak( writer );

        writeLineBreak( writer, 1, indent );
    }

    /**
     * Convenience method to write XML ant task
     *
     * @param writer not null
     * @param project not null
     * @param moduleSubPath not null
     * @param tasks not null
     */
    public static void writeAntTask( XMLWriter writer, MavenProject project, String moduleSubPath, String tasks )
    {
        writer.startElement( "ant" );
        writer.addAttribute( "antfile", "build.xml" );
        writer.addAttribute( "dir", PathUtils.toRelative( project.getBasedir(), moduleSubPath ) );
        writer.addAttribute( "target", tasks );
        writer.endElement(); // ant
    }

    /**
     * Convenience method to write XML Ant javadoc task
     *
     * @param writer not null
     * @param project not null
     * @param wrapper not null
     * @throws IOException if any
     */
    public static void writeJavadocTask( XMLWriter writer, MavenProject project, ArtifactResolverWrapper wrapper )
        throws IOException
    {
        List sources = new ArrayList();
        for ( Iterator it = project.getCompileSourceRoots().iterator(); it.hasNext(); )
        {
            String source = (String) it.next();

            if ( new File( source ).exists() )
            {
                sources.add( source );
            }
        }

        // No sources
        if ( sources.size() == 0 )
        {
            return;
        }

        writer.startElement( "javadoc" );
        String sourcepath = getMavenJavadocPluginBasicOption( project, "sourcepath", null );
        if ( sourcepath == null )
        {
            StringBuffer sb = new StringBuffer();
            String[] compileSourceRoots = (String[]) sources.toArray( new String[0] );
            for ( int i = 0; i < compileSourceRoots.length; i++ )
            {
                sb.append( "${maven.build.srcDir." ).append( i ).append( "}" );

                if ( i < ( compileSourceRoots.length - 1 ) )
                {
                    sb.append( File.pathSeparatorChar );
                }
            }
            writer.addAttribute( "sourcepath", sb.toString() );
            addWrapAttribute( writer, "javadoc", "packagenames", "*", 3 );
        }
        else
        {
            writer.addAttribute( "sourcepath", sourcepath );
        }
        addWrapAttribute( writer, "javadoc", "destdir",
                          getMavenJavadocPluginBasicOption( project, "destdir",
                                                            "${maven.reporting.outputDirectory}/apidocs" ), 3 );
        addWrapAttribute( writer, "javadoc", "extdirs", getMavenJavadocPluginBasicOption( project, "extdirs", null ), 3 );

        addWrapAttribute( writer, "javadoc", "overview", getMavenJavadocPluginBasicOption( project, "overview", null ),
                          3 );
        addWrapAttribute( writer, "javadoc", "access",
                          getMavenJavadocPluginBasicOption( project, "show", "protected" ), 3 );
        addWrapAttribute( writer, "javadoc", "old", getMavenJavadocPluginBasicOption( project, "old", "false" ), 3 );
        addWrapAttribute( writer, "javadoc", "verbose",
                          getMavenJavadocPluginBasicOption( project, "verbose", "false" ), 3 );
        addWrapAttribute( writer, "javadoc", "locale", getMavenJavadocPluginBasicOption( project, "locale", null ), 3 );
        addWrapAttribute( writer, "javadoc", "encoding", getMavenJavadocPluginBasicOption( project, "encoding", null ),
                          3 );
        addWrapAttribute( writer, "javadoc", "version", getMavenJavadocPluginBasicOption( project, "version", "true" ),
                          3 );
        addWrapAttribute( writer, "javadoc", "use", getMavenJavadocPluginBasicOption( project, "use", "true" ), 3 );
        addWrapAttribute( writer, "javadoc", "author", getMavenJavadocPluginBasicOption( project, "author", "true" ), 3 );
        addWrapAttribute( writer, "javadoc", "splitindex", getMavenJavadocPluginBasicOption( project, "splitindex",
                                                                                             "false" ), 3 );
        addWrapAttribute( writer, "javadoc", "windowtitle", getMavenJavadocPluginBasicOption( project, "windowtitle",
                                                                                              null ), 3 );
        addWrapAttribute( writer, "javadoc", "nodeprecated", getMavenJavadocPluginBasicOption( project, "nodeprecated",
                                                                                               "false" ), 3 );
        addWrapAttribute( writer, "javadoc", "nodeprecatedlist", getMavenJavadocPluginBasicOption( project,
                                                                                                   "nodeprecatedlist",
                                                                                                   "false" ), 3 );
        addWrapAttribute( writer, "javadoc", "notree", getMavenJavadocPluginBasicOption( project, "notree", "false" ),
                          3 );
        addWrapAttribute( writer, "javadoc", "noindex",
                          getMavenJavadocPluginBasicOption( project, "noindex", "false" ), 3 );
        addWrapAttribute( writer, "javadoc", "nohelp", getMavenJavadocPluginBasicOption( project, "nohelp", "false" ),
                          3 );
        addWrapAttribute( writer, "javadoc", "nonavbar",
                          getMavenJavadocPluginBasicOption( project, "nonavbar", "false" ), 3 );
        addWrapAttribute( writer, "javadoc", "serialwarn", getMavenJavadocPluginBasicOption( project, "serialwarn",
                                                                                             "false" ), 3 );
        addWrapAttribute( writer, "javadoc", "helpfile", getMavenJavadocPluginBasicOption( project, "helpfile", null ),
                          3 );
        addWrapAttribute( writer, "javadoc", "stylesheetfile",
                          getMavenJavadocPluginBasicOption( project, "stylesheetfile", null ), 3 );
        addWrapAttribute( writer, "javadoc", "charset", getMavenJavadocPluginBasicOption( project, "charset",
                                                                                          "ISO-8859-1" ), 3 );
        addWrapAttribute( writer, "javadoc", "docencoding", getMavenJavadocPluginBasicOption( project, "docencoding",
                                                                                              null ), 3 );
        addWrapAttribute( writer, "javadoc", "excludepackagenames",
                          getMavenJavadocPluginBasicOption( project, "excludepackagenames", null ), 3 );
        addWrapAttribute( writer, "javadoc", "source", getMavenJavadocPluginBasicOption( project, "source", null ), 3 );
        addWrapAttribute( writer, "javadoc", "linksource", getMavenJavadocPluginBasicOption( project, "linksource",
                                                                                             "false" ), 3 );
        addWrapAttribute( writer, "javadoc", "breakiterator", getMavenJavadocPluginBasicOption( project,
                                                                                                "breakiterator",
                                                                                                "false" ), 3 );
        addWrapAttribute( writer, "javadoc", "noqualifier", getMavenJavadocPluginBasicOption( project, "noqualifier",
                                                                                              null ), 3 );
        // miscellaneous
        addWrapAttribute( writer, "javadoc", "maxmemory",
                          getMavenJavadocPluginBasicOption( project, "maxmemory", null ), 3 );
        addWrapAttribute( writer, "javadoc", "additionalparam", getMavenJavadocPluginBasicOption( project,
                                                                                                  "additionalparam",
                                                                                                  null ), 3 );

        // Nested arg
        String doctitle = getMavenJavadocPluginBasicOption( project, "doctitle", null );
        if ( doctitle != null )
        {
            writer.startElement( "doctitle" );
            writer.writeText( "<![CDATA[" + doctitle + "]]>" );
            writer.endElement(); // doctitle
        }
        String header = getMavenJavadocPluginBasicOption( project, "header", null );
        if ( header != null )
        {
            writer.startElement( "header" );
            writer.writeText( "<![CDATA[" + header + "]]>" );
            writer.endElement(); // header
        }
        String footer = getMavenJavadocPluginBasicOption( project, "footer", null );
        if ( footer != null )
        {
            writer.startElement( "footer" );
            writer.writeText( "<![CDATA[" + footer + "]]>" );
            writer.endElement(); // footer
        }
        String bottom = getMavenJavadocPluginBasicOption( project, "bottom", null );
        if ( bottom != null )
        {
            writer.startElement( "bottom" );
            writer.writeText( "<![CDATA[" + bottom + "]]>" );
            writer.endElement(); // bottom
        }

        Map[] links = getMavenJavadocPluginOptions( project, "links", null );
        if ( links != null )
        {
            for ( int i = 0; i < links.length; i++ )
            {
                writer.startElement( "link" );
                writer.addAttribute( "href", (String) links[i].get( "link" ) );
                writer.endElement(); // link
            }
        }

        Map[] offlineLinks = getMavenJavadocPluginOptions( project, "offlineLinks", null );
        if ( offlineLinks != null )
        {
            for ( int i = 0; i < offlineLinks.length; i++ )
            {
                writer.startElement( "link" );
                writer.addAttribute( "href", (String) offlineLinks[i].get( "url" ) );
                addWrapAttribute( writer, "javadoc", "offline", "true", 4 );
                writer.endElement(); // link
            }
        }

        Map[] groups = getMavenJavadocPluginOptions( project, "groups", null );
        if ( groups != null )
        {
            for ( int i = 0; i < groups.length; i++ )
            {
                writer.startElement( "group" );
                writer.addAttribute( "title", (String) groups[i].get( "title" ) );
                addWrapAttribute( writer, "javadoc", "package", (String) groups[i].get( "package" ), 4 );
                writer.endElement(); // group
            }
        }

        // TODO Handle docletArtifacts
        String doclet = getMavenJavadocPluginBasicOption( project, "doclet", null );
        if ( doclet != null )
        {
            String docletpath = getMavenJavadocPluginBasicOption( project, "docletpath", null );
            if ( StringUtils.isNotEmpty( docletpath ) )
            {
                writer.startElement( "doclet" );
                writer.addAttribute( "name", doclet );
                addWrapAttribute( writer, "javadoc", "path", docletpath, 4 );
                writer.endElement(); // doclet
            }
            else
            {
                Map docletArtifact = getMavenJavadocPluginOption( project, "docletArtifact", null );
                String path = wrapper.getArtifactAbsolutePath( (String) docletArtifact.get( "groupId" ),
                                                               (String) docletArtifact.get( "artifactId" ),
                                                               (String) docletArtifact.get( "version" ) );
                path = StringUtils.replace( path, wrapper.getLocalRepository().getBasedir(), "${maven.repo.local}" );

                writer.startElement( "doclet" );
                writer.addAttribute( "name", doclet );
                addWrapAttribute( writer, "javadoc", "path", path, 4 );
                writer.endElement(); // doclet
            }
        }

        // TODO Handle taglets
        String taglet = getMavenJavadocPluginBasicOption( project, "taglet", null );
        if ( taglet != null )
        {
            String tagletpath = getMavenJavadocPluginBasicOption( project, "tagletpath", null );
            if ( StringUtils.isNotEmpty( tagletpath ) )
            {
                writer.startElement( "taglet" );
                writer.addAttribute( "name", taglet );
                addWrapAttribute( writer, "javadoc", "path", tagletpath, 4 );
                writer.endElement(); // taglet
            }
            else
            {
                Map tagletArtifact = getMavenJavadocPluginOption( project, "tagletArtifact", null );
                String path = wrapper.getArtifactAbsolutePath( (String) tagletArtifact.get( "groupId" ),
                                                               (String) tagletArtifact.get( "artifactId" ),
                                                               (String) tagletArtifact.get( "version" ) );
                path = StringUtils.replace( path, wrapper.getLocalRepository().getBasedir(), "${maven.repo.local}" );

                writer.startElement( "taglet" );
                writer.addAttribute( "name", taglet );
                addWrapAttribute( writer, "javadoc", "path", path, 4 );
                writer.endElement(); // taglet
            }
        }

        Map[] tags = getMavenJavadocPluginOptions( project, "tags", null );
        if ( tags != null )
        {
            for ( int i = 0; i < tags.length; i++ )
            {
                writer.startElement( "tag" );
                writer.addAttribute( "name", (String) tags[i].get( "name" ) );
                addWrapAttribute( writer, "javadoc", "scope", (String) tags[i].get( "placement" ), 4 );
                addWrapAttribute( writer, "javadoc", "description", (String) tags[i].get( "head" ), 4 );
                writer.endElement(); // tag
            }
        }

        writer.endElement(); // javadoc
    }

    /**
     * Convenience method to write XML Ant jar task
     *
     * @param writer not null
     * @param project not null
     * @throws IOException if any
     */
    public static void writeJarTask( XMLWriter writer, MavenProject project )
        throws IOException
    {
        writer.startElement( "jar" );
        writer.addAttribute( "jarfile", "${maven.build.dir}/${maven.build.finalName}.jar" );
        addWrapAttribute( writer, "jar", "compress",
                          getMavenJarPluginBasicOption( project, "archive//compress", "true" ), 3 );
        addWrapAttribute( writer, "jar", "index", getMavenJarPluginBasicOption( project, "archive//index", "false" ), 3 );
        if ( getMavenJarPluginBasicOption( project, "archive//manifestFile", null ) != null )
        {
            addWrapAttribute( writer, "jar", "manifest", getMavenJarPluginBasicOption( project,
                                                                                       "archive//manifestFile", null ),
                              3 );
        }
        addWrapAttribute( writer, "jar", "basedir", "${maven.build.outputDir}", 3 );
        addWrapAttribute( writer, "jar", "excludes", "**/package.html", 3 );
        if ( getMavenPluginOption( project, "maven-jar-plugin", "archive//manifest", null ) != null )
        {
            writer.startElement( "manifest" );
            writer.startElement( "attribute" );
            writer.addAttribute( "name", "Main-Class" );
            addWrapAttribute( writer, "attribute", "value",
                              getMavenJarPluginBasicOption( project, "archive//manifest//mainClass", null ), 5 );
            writer.endElement(); // attribute
            writer.endElement(); // manifest
        }
        writer.endElement(); // jar
    }

    /**
     * Convenience method to write XML Ant ear task
     *
     * @param writer not null
     * @param project not null
     * @throws IOException if any
     */
    public static void writeEarTask( XMLWriter writer, MavenProject project )
        throws IOException
    {
        writeCopyLib( writer, project, "${maven.build.dir}/${maven.build.finalName}" );

        writer.startElement( "ear" );
        writer.addAttribute( "destfile", "${maven.build.dir}/${maven.build.finalName}.ear" );
        addWrapAttribute( writer, "ear", "basedir", "${maven.build.dir}/${maven.build.finalName}", 3 );
        addWrapAttribute( writer, "ear", "compress",
                          getMavenEarPluginBasicOption( project, "archive//compress", "true" ), 3 );
        addWrapAttribute( writer, "ear", "includes ", getMavenEarPluginBasicOption( project, "includes", null ), 3 );
        addWrapAttribute( writer, "ear", "excludes", getMavenEarPluginBasicOption( project, "excludes", null ), 3 );
        if ( getMavenEarPluginBasicOption( project, "applicationXml", null ) != null )
        {
            addWrapAttribute( writer, "ear", "appxml", getMavenEarPluginBasicOption( project, "applicationXml", null ),
                              3 );
        }
        else
        {
            // Generated appxml
            addWrapAttribute( writer, "ear", "appxml", "${maven.build.dir}/application.xml", 3 );
        }
        if ( getMavenEarPluginBasicOption( project, "manifestFile", null ) != null )
        {
            addWrapAttribute( writer, "ear", "manifest", getMavenEarPluginBasicOption( project, "manifestFile", null ),
                              3 );
        }
        writer.endElement(); // ear
    }

    /**
     * Convenience method to write XML Ant war task
     *
     * @param writer not null
     * @param project not null
     * @param localRepository not null
     * @throws IOException if any
     */
    public static void writeWarTask( XMLWriter writer, MavenProject project, File localRepository )
        throws IOException
    {
        writeCopyLib( writer, project, "${maven.build.dir}/${maven.build.finalName}/WEB-INF/lib" );

        writer.startElement( "war" );
        writer.addAttribute( "destfile", "${maven.build.dir}/${maven.build.finalName}.war" );
        addWrapAttribute( writer, "war", "basedir", "${maven.build.outputDir}", 3 );
        addWrapAttribute( writer, "war", "compress",
                          getMavenWarPluginBasicOption( project, "archive//compress", "true" ), 3 );
        if ( getMavenWarPluginBasicOption( project, "webXml", null ) != null )
        {
            addWrapAttribute( writer, "war", "webxml", getMavenWarPluginBasicOption( project, "webXml", null ), 3 );
        }
        else
        {
            // Default
            addWrapAttribute( writer, "war", "webxml", "${basedir}/src/main/webapp/WEB-INF/web.xml", 3 );
        }
        if ( getMavenWarPluginBasicOption( project, "manifestFile", null ) != null )
        {
            addWrapAttribute( writer, "war", "manifest", getMavenWarPluginBasicOption( project, "manifestFile", null ),
                              3 );
        }
        writer.startElement( "lib" );
        writer.addAttribute( "dir", "${maven.build.dir}/${maven.build.finalName}/WEB-INF/lib" );
        writer.endElement(); // lib
        writer.startElement( "classes" );
        writer.addAttribute( "dir", "${maven.build.outputDir}" );
        writer.endElement(); // classes
        writer.startElement( "webinf" );
        writer.addAttribute( "dir", "${basedir}/src/main/webapp/WEB-INF" );
        addWrapAttribute( writer, "webinf", "excludes", "web.xml", 4 );
        writer.endElement(); // webinf
        writer.startElement( "fileset" );
        writer.addAttribute( "dir", "${basedir}/src/main/webapp" );
        writer.endElement(); // fileset
        writer.endElement(); // war
    }

    /**
     * Convenience method to wrap long element tags for a given attribute.
     *
     * @param writer not null
     * @param tag not null
     * @param name not null
     * @param value not null
     * @param indent positive value
     */
    public static void addWrapAttribute( XMLWriter writer, String tag, String name, String value, int indent )
    {
        if ( StringUtils.isEmpty( value ) )
        {
            return;
        }

        if ( indent < 0 )
        {
            writer.addAttribute( name, value );
        }
        else
        {
            writer.addAttribute( "\n"
                + StringUtils.repeat( " ", ( StringUtils.isEmpty( tag ) ? 0 : tag.length() ) + indent
                    * AntBuildWriter.DEFAULT_INDENTATION_SIZE ) + name, value );
        }
    }

    /**
     * @param mavenProject not null
     * @return true if project packaging equals <code>pom</code>
     */
    public static boolean isPomPackaging( MavenProject mavenProject )
    {
        return mavenProject.getPackaging().toLowerCase().equals( "pom" );
    }

    /**
     * @param mavenProject not null
     * @return true if project packaging equals <code>jar</code> or <code>maven-plugin</code>
     */
    public static boolean isJarPackaging( MavenProject mavenProject )
    {
        return mavenProject.getPackaging().toLowerCase().equals( "jar" )
            || mavenProject.getPackaging().toLowerCase().equals( "ejb" )
            || mavenProject.getPackaging().toLowerCase().equals( "maven-plugin" );
    }

    /**
     * @param mavenProject
     * @return true if project packaging equals <code>ear</code>
     */
    public static boolean isEarPackaging( MavenProject mavenProject )
    {
        return mavenProject.getPackaging().toLowerCase().equals( "ear" );
    }

    /**
     * @param mavenProject not null
     * @return true if project packaging equals <code>war</code>
     */
    public static boolean isWarPackaging( MavenProject mavenProject )
    {
        return mavenProject.getPackaging().toLowerCase().equals( "war" );
    }

    /**
     * Return the <code>optionName</code> value defined in a project for the "maven-compiler-plugin" plugin.
     *
     * @param project not null
     * @param optionName the option name wanted
     * @param defaultValue a default value
     * @return the value for the option name or the default value. Could be null if not found.
     * @throws IOException if any
     */
    public static String getMavenCompilerPluginBasicOption( MavenProject project, String optionName, String defaultValue )
        throws IOException
    {
        return getMavenPluginBasicOption( project, "maven-compiler-plugin", optionName, defaultValue );
    }

    /**
     * Return the map of <code>optionName</code> value defined in a project for the "maven-compiler-plugin" plugin.
     *
     * @param project not null
     * @param optionName the option name wanted
     * @param defaultValue a default value
     * @return the map for the option name or the default value. Could be null if not found.
     * @throws IOException if any
     */
    public static Map getMavenCompilerPluginOption( MavenProject project, String optionName, String defaultValue )
        throws IOException
    {
        return getMavenPluginOption( project, "maven-compiler-plugin", optionName, defaultValue );
    }

    /**
     * Return an array of map of <code>optionName</code> value defined in a project for the "maven-compiler-plugin" plugin.
     *
     * @param project not null
     * @param optionName the option name wanted
     * @param defaultValue a default value
     * @return the array of option name or the default value. Could be null if not found.
     * @throws IOException if any
     */
    public static Map[] getMavenCompilerPluginOptions( MavenProject project, String optionName, String defaultValue )
        throws IOException
    {
        return getMavenPluginOptions( project, "maven-compiler-plugin", optionName, defaultValue );
    }

    /**
     * Return the <code>optionName</code> value defined in a project for the "maven-surefire-plugin" plugin.
     *
     * @param project not null
     * @param optionName the option name wanted
     * @param defaultValue a default value
     * @return the value for the option name or the default value. Could be null if not found.
     * @throws IOException if any
     */
    public static String getMavenSurefirePluginBasicOption( MavenProject project, String optionName, String defaultValue )
        throws IOException
    {
        return getMavenPluginBasicOption( project, "maven-surefire-plugin", optionName, defaultValue );
    }

    /**
     * Return the map of <code>optionName</code> value defined in a project for the "maven-surefire-plugin" plugin.
     *
     * @param project not null
     * @param optionName the option name wanted
     * @param defaultValue a default value
     * @return the map for the option name or the default value. Could be null if not found.
     * @throws IOException if any
     */
    public static Map getMavenSurefirePluginOption( MavenProject project, String optionName, String defaultValue )
        throws IOException
    {
        return getMavenPluginOption( project, "maven-surefire-plugin", optionName, defaultValue );
    }

    /**
     * Return an array of map of <code>optionName</code> value defined in a project for the "maven-surefire-plugin" plugin.
     *
     * @param project not null
     * @param optionName the option name wanted
     * @param defaultValue a default value
     * @return the array of option name or the default value. Could be null if not found.
     * @throws IOException if any
     */
    public static Map[] getMavenSurefirePluginOptions( MavenProject project, String optionName, String defaultValue )
        throws IOException
    {
        return getMavenPluginOptions( project, "maven-surefire-plugin", optionName, defaultValue );
    }

    /**
     * Return the <code>optionName</code> value defined in a project for the "maven-javadoc-plugin" plugin.
     *
     * @param project not null
     * @param optionName the option name wanted
     * @param defaultValue a default value
     * @return the value for the option name or the default value. Could be null if not found.
     * @throws IOException if any
     */
    public static String getMavenJavadocPluginBasicOption( MavenProject project, String optionName, String defaultValue )
        throws IOException
    {
        return getMavenPluginBasicOption( project, "maven-javadoc-plugin", optionName, defaultValue );
    }

    /**
     * Return a map of <code>optionName</code> value defined in a project for the "maven-javadoc-plugin" plugin.
     *
     * @param project not null
     * @param optionName the option name wanted
     * @param defaultValue a default value
     * @return the map for the option name or the default value. Could be null if not found.
     * @throws IOException if any
     */
    public static Map getMavenJavadocPluginOption( MavenProject project, String optionName, String defaultValue )
        throws IOException
    {
        return getMavenPluginOption( project, "maven-javadoc-plugin", optionName, defaultValue );
    }

    /**
     * Return an array of map of <code>optionName</code> value defined in a project for the "maven-javadoc-plugin" plugin.
     *
     * @param project not null
     * @param optionName the option name wanted
     * @param defaultValue a default value
     * @return an array of option name. Could be null if not found.
     * @throws IOException if any
     */
    public static Map[] getMavenJavadocPluginOptions( MavenProject project, String optionName, String defaultValue )
        throws IOException
    {
        return getMavenPluginOptions( project, "maven-javadoc-plugin", optionName, defaultValue );
    }

    /**
     * Return the <code>optionName</code> value defined in a project for the "maven-jar-plugin" plugin.
     *
     * @param project not null
     * @param optionName the option name wanted
     * @param defaultValue a default value
     * @return the value for the option name or the default value. Could be null if not found.
     * @throws IOException if any
     */
    public static String getMavenJarPluginBasicOption( MavenProject project, String optionName, String defaultValue )
        throws IOException
    {
        return getMavenPluginBasicOption( project, "maven-jar-plugin", optionName, defaultValue );
    }

    /**
     * Return the <code>optionName</code> value defined in a project for the "maven-ear-plugin" plugin.
     *
     * @param project not null
     * @param optionName the option name wanted
     * @param defaultValue a default value
     * @return the value for the option name or the default value. Could be null if not found.
     * @throws IOException if any
     */
    public static String getMavenEarPluginBasicOption( MavenProject project, String optionName, String defaultValue )
        throws IOException
    {
        return getMavenPluginBasicOption( project, "maven-ear-plugin", optionName, defaultValue );
    }

    /**
     * Return the <code>optionName</code> value defined in a project for the "maven-war-plugin" plugin.
     *
     * @param project not null
     * @param optionName the option name wanted
     * @param defaultValue a default value
     * @return the value for the option name or the default value. Could be null if not found.
     * @throws IOException if any
     */
    public static String getMavenWarPluginBasicOption( MavenProject project, String optionName, String defaultValue )
        throws IOException
    {
        return getMavenPluginBasicOption( project, "maven-war-plugin", optionName, defaultValue );
    }

    // ----------------------------------------------------------------------
    // Convenience methods
    // ----------------------------------------------------------------------

    /**
     * Return the value for the option <code>optionName</code> defined in a project with the given
     * <code>artifactId</code> plugin.
     * <br/>
     * Example:
     * <table>
     *   <tr>
     *     <td>Configuration</td>
     *     <td>Result</td>
     *   </tr>
     *   <tr>
     *     <td><pre>&lt;option&gt;value&lt;/option&gt;</pre></td>
     *     <td><pre>value</pre></td>
     *   </tr>
     * </table>
     *
     * @param project not null
     * @param pluginArtifactId not null
     * @param optionName an <code>Xpath</code> expression from the plugin <code>&lt;configuration/&gt;</code>
     * @param defaultValue could be null
     * @return the value for the option name or null if not found
     * @throws IOException if any
     */
    private static String getMavenPluginBasicOption( MavenProject project, String pluginArtifactId, String optionName,
                                                    String defaultValue )
        throws IOException
    {
        return (String) getMavenPluginConfigurationsImpl( project, pluginArtifactId, optionName, defaultValue )
            .get( optionName );
    }

    /**
     * Return a Map for the option <code>optionName</code> defined in a project with the given
     * <code>artifactId</code> plugin.
     * <br/>
     * Example:
     * <table>
     *   <tr>
     *     <td>Configuration</td>
     *     <td>Result</td>
     *   </tr>
     *   <tr>
     *     <td><pre>
     * &lt;option&gt;
     *  &lt;param1&gt;value1&lt;/param1&gt;
     *  &lt;param2&gt;value2&lt;/param2&gt;
     * &lt;/option&gt;
     * </pre></td>
     *     <td><pre>{param1=value1, param2=value2}<pre></td>
     *   </tr>
     * </table>
     *
     * @param project not null
     * @param pluginArtifactId not null
     * @param optionName an <code>Xpath</code> expression from the plugin <code>&lt;configuration/&gt;</code>
     * @param defaultValue could be null
     * @return the value for the option name or null if not found
     * @throws IOException if any
     */
    private static Map getMavenPluginOption( MavenProject project, String pluginArtifactId, String optionName,
                                            String defaultValue )
        throws IOException
    {
        return (Map) getMavenPluginConfigurationsImpl( project, pluginArtifactId, optionName, defaultValue )
            .get( optionName );
    }

    /**
     * Return an array of Map for the option <code>optionName</code> defined in a project with the given
     * <code>artifactId</code> plugin.
     * <br/>
     * Example:
     * <table>
     *   <tr>
     *     <td>Configuration</td>
     *     <td>Result</td>
     *   </tr>
     *   <tr>
     *     <td><pre>
     * &lt;options&gt;
     *   &lt;option&gt;
     *    &lt;param1&gt;value1&lt;/param1&gt;
     *    &lt;param2&gt;value2&lt;/param2&gt;
     *   &lt;/option&gt;
     *   &lt;option&gt;
     *    &lt;param1&gt;value1&lt;/param1&gt;
     *    &lt;param2&gt;value2&lt;/param2&gt;
     *   &lt;/option&gt;
     * &lt;/options&gt;
     * </pre></td>
     *     <td><pre>[{option=[{param1=value1, param2=value2}]}, {option=[{param1=value1, param2=value2}]<pre></td>
     *   </tr>
     * </table>
     *
     * @param project not null
     * @param pluginArtifactId not null
     * @param optionName an <code>Xpath</code> expression from the plugin <code>&lt;configuration/&gt;</code>
     * @param defaultValue could be null
     * @return the value for the option name  or null if not found
     * @throws IOException if any
     */
    private static Map[] getMavenPluginOptions( MavenProject project, String pluginArtifactId, String optionName,
                                               String defaultValue )
        throws IOException
    {
        return (Map[]) getMavenPluginConfigurationsImpl( project, pluginArtifactId, optionName, defaultValue )
            .get( optionName );
    }

    /**
     * Return a Map for the option <code>optionName</code> defined in a project with the given
     * <code>artifactId</code> plugin.
     * <br/>
     * Example:
     * <table>
     *   <tr>
     *     <td>Configuration</td>
     *     <td>Result</td>
     *   </tr>
     *   <tr>
     *     <td><pre>&lt;option&gt;value&lt;/option&gt;</pre></td>
     *     <td><pre>{option=value}</pre></td>
     *   </tr>
     *   <tr>
     *     <td><pre>
     * &lt;option&gt;
     *  &lt;param1&gt;value1&lt;/param1&gt;
     *  &lt;param2&gt;value2&lt;/param2&gt;
     * &lt;/option&gt;
     * </pre></td>
     *     <td><pre>{option={param1=value1, param2=value2}}<pre></td>
     *   </tr>
     *   <tr>
     *     <td><pre>
     * &lt;options&gt;
     *   &lt;option&gt;
     *    &lt;param1&gt;value1&lt;/param1&gt;
     *    &lt;param2&gt;value2&lt;/param2&gt;
     *   &lt;/option&gt;
     *   &lt;option&gt;
     *    &lt;param1&gt;value1&lt;/param1&gt;
     *    &lt;param2&gt;value2&lt;/param2&gt;
     *   &lt;/option&gt;
     * &lt;/options&gt;
     * </pre></td>
     *     <td><pre>{options=[{option=[{param1=value1, param2=value2}]}, {option=[{param1=value1, param2=value2}]}]<pre></td>
     *   </tr>
     * </table>
     *
     * @param project not null
     * @param pluginArtifactId not null
     * @param optionName an <code>Xpath</code> expression from the plugin <code>&lt;configuration/&gt;</code>
     * @param defaultValue could be null
     * @return a map with the options found
     * @throws IOException if any
     */
    private static Map getMavenPluginConfigurationsImpl( MavenProject project, String pluginArtifactId,
                                                        String optionName, String defaultValue )
        throws IOException
    {
        List plugins = new ArrayList();
        for ( Iterator it = project.getModel().getReporting().getPlugins().iterator(); it.hasNext(); )
        {
            plugins.add( it.next() );
        }
        for ( Iterator it = project.getModel().getBuild().getPlugins().iterator(); it.hasNext(); )
        {
            plugins.add( it.next() );
        }

        for ( Iterator it = plugins.iterator(); it.hasNext(); )
        {
            Object next = it.next();

            Xpp3Dom pluginConf = null;

            if ( next instanceof Plugin )
            {
                Plugin plugin = (Plugin) next;

                // using out-of-box Maven plugins
                if ( !( ( plugin.getGroupId().equals( "org.apache.maven.plugins" ) ) && ( plugin.getArtifactId()
                    .equals( pluginArtifactId ) ) ) )
                {
                    continue;
                }

                pluginConf = (Xpp3Dom) plugin.getConfiguration();
            }

            if ( next instanceof ReportPlugin )
            {
                ReportPlugin reportPlugin = (ReportPlugin) next;

                // using out-of-box Maven plugins
                if ( !( ( reportPlugin.getGroupId().equals( "org.apache.maven.plugins" ) ) && ( reportPlugin
                    .getArtifactId().equals( pluginArtifactId ) ) ) )
                {
                    continue;
                }

                pluginConf = (Xpp3Dom) reportPlugin.getConfiguration();
            }

            if ( pluginConf == null )
            {
                continue;
            }

            try
            {
                Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder()
                    .parse( new ByteArrayInputStream( pluginConf.toString().getBytes( "UTF-8" ) ) );

                XObject obj = XPathAPI.eval( doc, "//configuration/" + optionName );

                NodeList nodeList = obj.nodelist();
                if ( nodeList.getLength() > 0 && isList( nodeList.item( 0 ) ) )
                {
                    /*
                     * <optionNames>
                     *   <optionName>
                     *    <param1>value1</param1>
                     *    <param2>value2</param2>
                     *   </optionName>
                     * </optionNames>
                     */
                    Map options = new HashMap();

                    List optionNames = new ArrayList();
                    NodeList childs = nodeList.item( 0 ).getChildNodes();
                    for ( int i = 0; i < childs.getLength(); i++ )
                    {
                        if ( childs.item( i ).getNodeType() == Node.ELEMENT_NODE )
                        {
                            Map option = new HashMap();

                            obj = XPathAPI.eval( doc, "//configuration/" + childs.item( i ).getNodeName() );

                            if ( StringUtils.isNotEmpty( obj.toString() ) )
                            {
                                Map properties = new HashMap();
                                NodeList childs2 = childs.item( i ).getChildNodes();
                                if ( childs2.getLength() > 0 )
                                {
                                    for ( int j = 0; j < childs2.getLength(); j++ )
                                    {
                                        if ( childs2.item( j ).getNodeType() == Node.ELEMENT_NODE )
                                        {
                                            properties.put( childs2.item( j ).getNodeName(), childs2.item( j )
                                                .getFirstChild().getNodeValue() );
                                        }
                                    }
                                    option.put( childs.item( i ).getNodeName(), properties );
                                }
                            }
                            else
                            {
                                option.put( childs.item( i ).getNodeName(), childs.item( i ).getFirstChild()
                                    .getNodeValue() );
                            }

                            optionNames.add( option );
                        }
                    }

                    options.put( optionName, optionNames.toArray( new Map[0] ) );

                    return options;
                }

                /*
                 * <optionName>
                 *  <param1>value1</param1>
                 *  <param2>value2</param2>
                 * </optionName>
                 */
                if ( StringUtils.isNotEmpty( obj.toString() ) )
                {
                    Map option = new HashMap();

                    NodeList childs = nodeList.item( 0 ).getChildNodes();
                    if ( childs.getLength() > 1 )
                    {
                        Map parameters = new HashMap();

                        for ( int i = 0; i < childs.getLength(); i++ )
                        {
                            if ( childs.item( i ).getNodeType() == Node.ELEMENT_NODE )
                            {
                                parameters.put( childs.item( i ).getNodeName(), childs.item( i ).getFirstChild()
                                    .getNodeValue() );
                            }
                        }

                        option.put( optionName, parameters );
                    }
                    else
                    {
                        /*
                         * <optionName>value1</optionName>
                         */
                        option.put( optionName, obj.toString() );
                    }

                    return option;
                }
            }
            catch ( Exception e )
            {
                throw new IOException( "Exception occured: " + e.getMessage() );
            }
        }

        Map properties = new HashMap();
        properties.put( optionName, defaultValue );

        return properties;
    }

    /**
     * Write copy tasks in an outputDir for EAR and WAR targets for project depencies without
     * <code>provided</code> or <code>test</code> as scope
     *
     * @param writer not null
     * @param project not null
     * @param outputDir not null
     */
    private static void writeCopyLib( XMLWriter writer, MavenProject project, String outputDir )
    {
        writer.startElement( "mkdir" );
        writer.addAttribute( "dir", outputDir );
        writer.endElement(); // mkdir

        if ( !project.getDependencyArtifacts().isEmpty() )
        {
            for ( Iterator i = project.getDependencyArtifacts().iterator(); i.hasNext(); )
            {
                Artifact artifact = (Artifact) i.next();

                if ( !artifact.getScope().equals( Artifact.SCOPE_PROVIDED )
                    && !artifact.getScope().equals( Artifact.SCOPE_TEST ) )
                {
                    writer.startElement( "copy" );
                    writer.addAttribute( "file", artifact.getFile().getPath() );
                    addWrapAttribute( writer, "copy", "todir", outputDir, 3 );
                    writer.endElement(); // copy
                }
            }
        }
    }

    /**
     * Check if a given <code>node</code> is a list of nodes or not.
     * <br/>
     * For instance, the node <code>options</code> is a list of <code>option</code> in the following case:
     *<pre>
     * &lt;options&gt;
     *   &lt;option&gt;
     *    &lt;param1&gt;value1&lt;/param1&gt;
     *    &lt;param2&gt;value2&lt;/param2&gt;
     *   &lt;/option&gt;
     *   &lt;option&gt;
     *    &lt;param1&gt;value1&lt;/param1&gt;
     *    &lt;param2&gt;value2&lt;/param2&gt;
     *   &lt;/option&gt;
     * &lt;/options&gt;
     * </pre>
     *
     * @param node a given node
     * @return true if the node is a list, false otherwise.
     */
    private static boolean isList( Node node )
    {
        if ( node == null )
        {
            return false;
        }

        NodeList childs = node.getChildNodes();

        boolean isList = false;
        String lastNodeName = null;
        for ( int i = 0; i < childs.getLength(); i++ )
        {
            Node child = childs.item( i );
            if ( child.getNodeType() == Node.ELEMENT_NODE )
            {
                isList = isList || ( child.getNodeName().equals( lastNodeName ) );
                lastNodeName = child.getNodeName();
            }
        }
        if ( StringUtils.isNotEmpty( lastNodeName ) )
        {
            isList = isList || lastNodeName.equals( getSingularForm( node.getNodeName() ) );
        }

        return isList;
    }

    /**
     * Gets the singular form of the specified (English) plural form. For example:
     * 
     * <pre>
     * properties -&gt; property
     * branches   -&gt; branch
     * reports    -&gt; report
     * </pre>
     * 
     * @param pluralForm The plural form for which to derive the singular form, may be <code>null</code>.
     * @return The corresponding singular form or an empty string if the input string was not recognized as a plural
     *         form.
     */
    static String getSingularForm( String pluralForm )
    {
        String singularForm = "";
        if ( StringUtils.isNotEmpty( pluralForm ) )
        {
            if ( pluralForm.endsWith( "ies" ) )
            {
                singularForm = pluralForm.substring( 0, pluralForm.length() - 3 ) + 'y';
            }
            else if ( pluralForm.endsWith( "ches" ) )
            {
                singularForm = pluralForm.substring( 0, pluralForm.length() - 2 );
            }
            else if ( pluralForm.endsWith( "s" ) && pluralForm.length() > 1 )
            {
                singularForm = pluralForm.substring( 0, pluralForm.length() - 1 );
            }
        }
        return singularForm;
    }

}
