  ---
  Advanced Assembly-Descriptor Topics
  ---
  John Casey
  ---
  1 December 2006

~~ Copyright 2006 The Apache Software Foundation.
~~
~~ Licensed under the Apache License, Version 2.0 (the "License");
~~ you may not use this file except in compliance with the License.
~~ You may obtain a copy of the License at
~~
~~      http://www.apache.org/licenses/LICENSE-2.0
~~
~~ Unless required by applicable law or agreed to in writing, software
~~ distributed under the License is distributed on an "AS IS" BASIS,
~~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
~~ See the License for the specific language governing permissions and
~~ limitations under the License.

~~ NOTE: For help with the syntax of this file, see:
~~ http://maven.apache.org/guides/mini/guide-apt-format.html


Advanced Assembly-Descriptor Topics

* Quick Note on All <<<includes>>> and <<<excludes>>> Patterns

  <<<excludes>>> take priority over <<<includes>>>.

* Advanced Artifact-Matching in <<<includes>>> and <<<excludes>>>

  When using <<<dependencySet>>> or <<<moduleSet>>>, the <<<\<includes/\>>>> and
  <<<\<excludes/\>>>> sections actually apply to artifacts, not filenames.
  This can be a good thing, since you don't have to know the artifact's
  filename in the local repository. However, explicitly specifying the full 
  artifact ID (consisting of groupId, artifactId, version, type, and classifier) 
  for each artifact to be included or excluded can lead to very a verbose
  descriptor. Starting with version 2.2, the assembly plugin addresses the 
  clumsiness of explicit artifact identification through the use of wildcard 
  patterns. 
  
  The following easy rules should be applied when specifying artifact-matching
  patterns:
  
  [[1]] Artifacts are matched by a set of identifier strings. In the following
        strings, <<<type>>> is <<<'jar'>>> by default, and <<<classifier>>> is 
        omitted if null.
  
                  # ArtifactUtils.versionlessKey( artifact )
                  # artifact.getDependencyConflictId()
                  # artifact.getId()
        * <<<groupId:artifactId:type:classifier>>>
          ( <<<artifact.getDependencyConflictId()>>> )
        
        * <<<groupId:artifactId>>> 
          ( <<<ArtifactUtils.versionlessKey( artifact )>>> )
        
        * <<<groupId:artifactId:version:type:classifier>>>
          ( <<<artifact.getId()>>> )
          
        []
        
  [[2]] Any <<<'*'>>> character in an include/exclude pattern will result in the
        pattern being split, and the sub-patterns being matched within the three
        artifact identifiers mentioned above, using <<<String.indexOf(..)>>>.
        
  [[3]] When no <<<'*'>>> is present in an include/exclude pattern, the pattern
        will only match if the <<entire>> pattern equals one of the three
        artifact identifiers above, using the <<<String.equals(..)>>> method.
        
  [[4]] In case you missed it above, artifact-identification fields are
        separated by colons (<<<':'>>>) in the matching strings. So, a wildcard
        pattern that matches any artifact of type <<<'war'>>> might be specified
        as <<<*:war>>>.
        
  []
  
** Example: Include all dependencies of type <<<'war'>>>

  In this example, we'll configure a <<<dependencySet>>> so it only includes
  those <<<war>>> dependencies.
  
---
<assembly>
  [...]
  <dependencySets>
    <dependencySet>
      <includes>
        <include>*:war</include>
      </includes>
    </dependencySet>
  </dependencySets>
  [...]
</assembly>
---

*** GOTCHA!

  In the above example, any <<<war>>> artifacts that happen to have a classifier
  (not sure why this particular case would happen, but it <is> possible) will be
  <<skipped>>. If you <really> want to be careful about catching all of the 
  <<<war>>> artifacts in your project, you might want to use the following
  pattern:
  
---
*:war:*
---

