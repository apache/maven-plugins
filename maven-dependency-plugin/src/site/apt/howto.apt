
~~ Licensed to the Apache Software Foundation (ASF) under one
~~ or more contributor license agreements.  See the NOTICE file
~~ distributed with this work for additional information
~~ regarding copyright ownership.  The ASF licenses this file
~~ to you under the Apache License, Version 2.0 (the
~~ "License"); you may not use this file except in compliance
~~ with the License.  You may obtain a copy of the License at
~~
~~ http://www.apache.org/licenses/LICENSE-2.0
~~
~~ Unless required by applicable law or agreed to in writing,
~~ software distributed under the License is distributed on an
~~ "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
~~ KIND, either express or implied.  See the License for the
~~ specific language governing permissions and limitations
~~ under the License.    
 

 ------
 Maven 2 dependency Plugin
 ------

How to use

 Brief examples on how to use the dependency goals.

* Generic Plugin configuration information

  See the following links for information about including and configuring plugins in your project:
  
  *{{{http://maven.apache.org/guides/mini/guide-configuring-plugins.html}Configuring Plugins}}
  
  *{{{http://maven.apache.org/guides/plugin/guide-java-plugin-development.html}Plugin Development}}

  *{{{http://maven.apache.org/guides/introduction/introduction-to-plugin-prefix-mapping.html}Plugin Prefix}}
 
* How to use dependency:copy

   This goal is meant to be bound to a lifecycle and configured in your pom.xml. 
   It will resolve the artifact from the repository and place a copy in the specified location. 
   Multiple artifacts can be defined in a single execution. A default output directory is 
   specified but can be overriden for each ArtifactItem by setting the optional outputDirectory field.
   An optional new name can be set to rename while copying. 
   The artifact version is optional. If not set, the plugin will attempt to resolve 
   from the dependencyManagement section.
   
   Artifacts are copied using the following rules:
   
     *If the artifactItem.overWrite is set, use that value.
     
     *Releases use the overWriteReleases value (default = true)
     
     *Snapshots use the overWriteSnapshots value (default = false)

-------------------
<project>

  ...
  <build>
   <plugins>
     <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-dependency-plugin</artifactId>
        <executions>
          <execution>
            <id>copy</id>
            <phase>package</phase>
            <goals>
              <goal>copy</goal>
            </goals>
            <configuration>
                <artifactItems>
                  <artifactItem>
                     <groupId>junit</groupId>
                     <artifactId>junit</artifactId>
                     <version>3.8.1</version>
                     <type>jar</type>
                     <overWrite>false</overWrite>
                     <outputDirectory>${project.build.directory}/alternateLocation</location>
                     <destFileName>optional-new-name.jar</destFileName>
                   </artifactItem>
                 </artifactItems>
               <outputDirectory>${project.build.directory}/wars</outputDirectory>
               <overWriteReleases>false</overWriteReleases>
               <overWriteSnapshots>true</overWriteSnapshots>
            </configuration>
          </execution>
        </executions>
      </plugin>
    </plugins>
  </build>
</project>
-------------------
 
    The dependency:copy goal can also be used to copy the just built artifact to a custom location if desired. It must be bound after the install phase so that the artifact exists in the repository. The following configuration shows how:
    
------------------
 <project>
  ...
  <build>
   <plugins>
     <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-dependency-plugin</artifactId>
        <executions>
          <execution>
            <id>copy-installed</id>
            <phase>install</phase>
            <goals>
              <goal>copy</goal>
            </goals>
            <configuration>
                <artifactItems>
                  <artifactItem>
                     <groupId>${project.groupId}</groupId>
                     <artifactId>${project.artifactId}</artifactId>
                     <version>${project.version}</version>
                     <type>${project.packaging}</type>
                  </artifactItem>
                 </artifactItems>
               <outputDirectory>some-other-place</outputDirectory>
            </configuration>
          </execution>
        </executions>
      </plugin>
    </plugins>
  </build>
</project>
------------------


* How to use dependency:copy-dependencies

   This goal can be bound to a lifecycle and configured in your pom.xml. 
   It will resolve the dependencies (including transitive dependencies) from the repository 
   and place a copy in the specified location. All scopes are included by default, but it can be limited
   to a single scope.
   
   Copy-dependencies includes transitive dependencies by default. To include only direct dependencies, set the excludeTransitive parameter to true.
   
   Dependencies can be included or excluded by a list of types. See {{{copy-dependencies-mojo.html}copy-dependencies}} for details.
   
   The artifacts can be placed in subfolders based on type. For example:
   
   \outputDirectory
   
   \outputDirectory\jars
   
   \outputDirectory\wars
   
   The artifacts can be placed in a subfolder per artifact. For example:
   \outputDirectory\junit-junit-3.8.1\
   This feature also works with the subfolders per type. For example:
   \outputDirectory\jars\junit-junit-3.8.1\
   
   Artifacts can also be resolved by specifying the classifer and optionally type. Type is only used with the classifier
   and defaults to java-sources. When the classifier is set, the list of dependencies is used as the base to resolve artifacts with
   the classifer and type. For example: mvn dependency:copy-dependencies -Dclassifer=sources will try to find the sources for all
   dependencies and copy them. 
   
   By default, SNAPSHOTs are always overwritten, Releases are not. This can be changed via the optional parameters.
   
   The goal can also be launched from the command line like: mvn dependency:copy-dependencies [optional params]
   
-------------------
<project>

  ...
  <build>
   <plugins>
     <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-dependency-plugin</artifactId>
        <executions>
          <execution>
            <id>copy-dependencies</id>
            <phase>package</phase>
            <goals>
              <goal>copy-dependencies</goal>
            </goals>
            <configuration>
              <outputDirectory>${project.build.directory}/alternateLocation</outputDirectory>
              <overWriteReleases>false</overWriteReleases>
              <overWriteSnapshots>true</overWriteSnapshots>
            </configuration>
          </execution>
        </executions>
      </plugin>
    </plugins>
  </build>
</project>
-------------------


* How to use dependency:unpack

   This goal is meant to be bound to a lifecycle and configured in your pom.xml. 
   It will resolve the artifact from the repository and place a copy in the specified location. 
   Multiple artifacts can be defined in a single execution. A default outputDirectory is specified 
   but can be overriden for each ArtifactItem by setting the optional outputDirectory field.
   Artifacts are unpacked using the following rules:
   
     *If the artifactItem.overWrite is set, use that value.
     
     *Releases use the overWriteReleases value (default = true)
     
     *Snapshots use the overWriteSnapshots value (default = false)
     
   The artifact version is optional. If not set, the plugin will attempt to resolve 
   from the dependencyManagement section.

-------------------
<project>

  ...
  <build>
   <plugins>
     <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-dependency-plugin</artifactId>
        <executions>
          <execution>
            <id>unpack</id>
            <phase>package</phase>
            <goals>
              <goal>unpack</goal>
            </goals>
            <configuration>
                <artifactItems>
                  <artifactItem>
                     <groupId>junit</groupId>
                     <artifactId>junit</artifactId>
                     <version>3.8.1</version>
                     <type>jar</type>
                     <overWrite>false</overWrite>
                     <outputDirectory>${project.build.directory}/alternateLocation</outputDirectory>
                   </artifactItem>
                 </artifactItems>
               <outputDirectory>${project.build.directory}</outputDirectory>
               <overWriteReleases>false</overWriteReleases>
               <overWriteSnapshots>true</overWriteSnapshots>
            </configuration>
          </execution>
        </executions>
      </plugin>
    </plugins>
  </build>
</project>
-------------------

* How to use dependency:unpack-dependencies

   This goal can be bound to a lifecycle and configured in your pom.xml. 
   It will resolve the dependencies (including transitive dependencies) from the repository 
   and unpack them to the specified location. All scopes are included by default, but it can be limited
   to a single scope.
   
   Unpack-dependencies includes transitive dependencies by default. To include only direct dependencies, set the excludeTransitive parameter to true.

   Dependencies can be included or excluded by a list of types. See {{{unpack-dependencies-mojo.html}unpack-dependencies}} for details.
   
   The artifacts can be unpacked in subfolders based on type. For example:
   
   \outputDirectory
   
   \outputDirectory\jars
   
   \outputDirectory\wars
   
   The artifacts can be placed in a subfolder per artifact. For example:
   \outputDirectory\junit-junit-3.8.1\
   This feature also works with the subfolders per type. For example:
   \outputDirectory\jars\junit-junit-3.8.1\
   
   Artifacts can also be resolved by specifying the classifer and optionally type. Type is only used with the classifier
   and defaults to java-sources. When the classifier is set, the list of dependencies is used as the base to resolve artifacts with
   the classifer and type. For example: mvn dependency:unpack-dependencies -Dclassifer=sources will try to find the sources for all
   dependencies and unpack them.
   
   By default, SNAPSHOTs are always overwritten, Releases are not. This can be changed via the optional parameters.
   
   The goal can also be launched from the command line like: mvn dependency:unpack-dependencies [optional params]
      
-------------------
<project>

  ...
  <build>
   <plugins>
     <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-dependency-plugin</artifactId>
        <executions>
          <execution>
            <id>unpack-dependencies</id>
            <phase>package</phase>
            <goals>
              <goal>unpack-dependencies</goal>
            </goals>
            <configuration>
              <outputDirectory>${project.build.directory}/alternateLocation</outputDirectory>
              <overWriteReleases>false</overWriteReleases>
              <overWriteSnapshots>true</overWriteSnapshots>
            </configuration>
          </execution>
        </executions>
      </plugin>
    </plugins>
  </build>
</project>
-------------------

* How to use dependency:resolve

  Resolve is intended to be used from the command line like: mvn dependency:resolve [-Dsilent=true]

  This goal simply tells maven to resolve all test scope (includes compile) dependencies and then displays the
  resolved versions. This is intended to help ensure all dependencies are downloaded to the local repository.
  This is usefull when troubleshooting or during intermittent remote repository failures when repeatedly building
  multiproject modules is undersirable and the build is failing on dependency resolution. It can also be used to quickly
  determine how versions are being resolved.
  
   Artifacts can also be resolved by specifying the classifer and optionally type. Type is only used with the classifier
   and defaults to java-sources. When the classifier is set, the list of dependencies is used as the base to resolve artifacts with
   the classifer and type. For example: mvn dependency:resolve -Dclassifer=test-jar will try to find the test-jar for all
   dependencies resolve them to the local repository.

* How to use dependency:sources

  Sources is intended to be used from the command line like: mvn dependency:sources [-Dsilent=true]

  This is the same as the resolve goal except it includes the source attachments if they exist.
  This is useful when you want the source attachments downloaded to your local repository and
  you don't want to use the eclipse plugin to do this since the eclipse plugin creates/overwrites the
  eclipse files. 
  
* How to use dependency:resolve-plugins
   
  Resolve-plugins is intended to be used from the command line like: mvn dependency:resolve-plugins [-Dsilent=true, -DexcludeTransitive=true]

  This is the same as the resolve goal except it resolves plugins and optionally their dependencies.  
  
* How to use dependency:go-offline
   
  This goal is exactly the same as calling mvn dependency:resolve dependency:resolve-plugins.
  
  For full documentation, click {{{index.html}here}}.
  
